/**
 * Options for representation retrieval.
 */
export interface RepresentationOptions {
    /**
     * Semantic search query to filter relevant conclusions.
     */
    searchQuery?: string;
    /**
     * Number of semantically relevant conclusions to return.
     */
    searchTopK?: number;
    /**
     * Maximum semantic distance for search results (0.0-1.0).
     */
    searchMaxDistance?: number;
    /**
     * Whether to include the most frequent conclusions.
     */
    includeMostFrequent?: boolean;
    /**
     * Maximum number of conclusions to include.
     */
    maxConclusions?: number;
}
/**
 * Metadata associated with a conclusion.
 */
export interface ConclusionMetadata {
    created_at: string;
    message_ids: Array<[number, number]>;
    session_name: string;
}
/**
 * An explicit conclusion with full metadata.
 * Represents facts LITERALLY stated - direct quotes or clear paraphrases only.
 */
export interface ExplicitConclusionBase {
    content: string;
}
/**
 * Base interface for deductive conclusions - logical conclusions.
 */
export interface DeductiveConclusionBase {
    premises: string[];
    conclusion: string;
}
export interface ExplicitConclusion extends ExplicitConclusionBase, ConclusionMetadata {
}
/**
 * A deductive conclusion with full metadata.
 * Represents conclusions that MUST be true given explicit facts and premises.
 */
export interface DeductiveConclusion extends DeductiveConclusionBase, ConclusionMetadata {
}
/**
 * Raw representation data structure returned from the API.
 */
export interface RepresentationData {
    explicit: ExplicitConclusion[];
    deductive: DeductiveConclusion[];
}
/**
 * A Representation is a traversable and diffable map of conclusions.
 *
 * At the base, we have a list of explicit conclusions, derived from a peer's messages.
 * From there, deductive conclusions can be made by establishing logical relationships
 * between explicit conclusions.
 *
 * All of a peer's conclusions are stored as documents in a collection. These documents
 * can be queried in various ways to produce this Representation object.
 *
 * A "working representation" is a version of this data structure representing the most
 * recent conclusions within a single session.
 */
export declare class Representation {
    /**
     * Facts LITERALLY stated - direct quotes or clear paraphrases only, no interpretation or inference.
     */
    explicit: ExplicitConclusion[];
    /**
     * Conclusions that MUST be true given explicit facts and premises - strict logical necessities.
     */
    deductive: DeductiveConclusion[];
    /**
     * Create a new Representation from conclusion lists.
     *
     * @param explicit - List of explicit conclusions
     * @param deductive - List of deductive conclusions
     */
    constructor(explicit?: ExplicitConclusion[], deductive?: DeductiveConclusion[]);
    /**
     * Check if the representation is empty.
     *
     * @returns True if both explicit and deductive conclusion lists are empty
     */
    isEmpty(): boolean;
    /**
     * Given this and another representation, return a new representation with only
     * conclusions that are unique to the other.
     *
     * Note: This only removes literal duplicates based on stringified comparison,
     * not semantically equivalent ones.
     *
     * @param other - The representation to compare against
     * @returns A new Representation containing only conclusions unique to other
     */
    diff(other: Representation): Representation;
    /**
     * Merge another representation into this one.
     *
     * This automatically deduplicates explicit and deductive conclusions.
     * Preserves order of conclusions to retain FIFO order.
     *
     * Note: Conclusions with the same timestamp may not have order preserved,
     * but that's acceptable since they're from the same timestamp.
     *
     * @param other - The representation to merge into this one
     * @param maxConclusions - Optional maximum number of conclusions to keep per type
     */
    merge(other: Representation, maxConclusions?: number): void;
    /**
     * Format representation into a clean, readable string for LLM prompts.
     *
     * Timestamps are stripped of subsecond precision for cleaner display.
     *
     * @returns Formatted string with clear sections and numbered items including timestamps
     *
     * @example
     * ```
     * EXPLICIT:
     * 1. [2025-01-01T12:00:00Z] The user has a dog named Rover
     * 2. [2025-01-01T12:01:00Z] The user's dog is 5 years old
     *
     * DEDUCTIVE:
     * 1. [2025-01-01T12:01:00Z] Rover is 5 years old
     *     - The user has a dog named Rover
     *     - The user's dog is 5 years old
     * ```
     */
    toString(): string;
    /**
     * Format representation into a clean, readable string without timestamps.
     *
     * @returns Formatted string with clear sections and numbered items without temporal metadata
     *
     * @example
     * ```
     * EXPLICIT:
     * 1. The user has a dog named Rover
     * 2. The user's dog is 5 years old
     *
     * DEDUCTIVE:
     * 1. Rover is 5 years old
     *     - The user has a dog named Rover
     *     - The user's dog is 5 years old
     * ```
     */
    toStringNoTimestamps(): string;
    /**
     * Format a Representation object as markdown.
     *
     * Timestamps are stripped of subsecond precision for cleaner display.
     *
     * @returns Formatted markdown string with headers and lists
     */
    toMarkdown(): string;
    /**
     * Create a Representation from raw API response data.
     *
     * @param data - Raw representation data from the API
     * @returns A new Representation instance
     */
    static fromData(data: RepresentationData): Representation;
    /**
     * Create a hash string for an explicit conclusion for deduplication.
     * Based on content, created_at, and session_name.
     */
    private _hashExplicit;
    /**
     * Create a hash string for a deductive conclusion for deduplication.
     * Based on conclusion, created_at, and session_name (premises not included).
     */
    private _hashDeductive;
    /**
     * Strip microseconds from ISO timestamp for cleaner display.
     */
    private _stripMicroseconds;
    /**
     * Safely parse a timestamp and return milliseconds since epoch for sorting.
     * Handles microsecond precision by truncating to milliseconds before parsing.
     *
     * @param timestamp - ISO 8601 timestamp string (may include microseconds)
     * @returns Milliseconds since epoch, or 0 if parsing fails
     */
    private _parseTimestampForSort;
}
