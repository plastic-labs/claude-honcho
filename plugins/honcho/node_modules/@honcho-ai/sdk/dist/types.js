"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DialecticStreamResponse = void 0;
/**
 * Iterator for streaming dialectic responses with utilities for accessing the final response.
 *
 * Similar to OpenAI and Anthropic streaming patterns, this allows you to:
 * - Iterate over chunks as they arrive
 * - Access the final accumulated response after streaming completes
 *
 * @example
 * ```typescript
 * const stream = await peer.chat("Hello", { stream: true })
 *
 * // Stream chunks
 * for await (const chunk of stream) {
 *   process.stdout.write(chunk)
 * }
 *
 * // Get final response object
 * const final = stream.getFinalResponse()
 * console.log(`\nFull content: ${final.content}`)
 * ```
 */
class DialecticStreamResponse {
    constructor(iterator) {
        this.accumulatedContent = [];
        this._isComplete = false;
        this.iterator = iterator;
    }
    [Symbol.asyncIterator]() {
        return {
            next: async () => {
                const result = await this.iterator.next();
                if (result.done) {
                    this._isComplete = true;
                    return { done: true, value: undefined };
                }
                this.accumulatedContent.push(result.value);
                return { done: false, value: result.value };
            },
        };
    }
    /**
     * Get the final accumulated response after streaming completes.
     *
     * @returns An object with the full content
     *
     * @note This should be called after the stream has been fully consumed.
     *       If called before completion, it returns the content accumulated so far.
     */
    getFinalResponse() {
        return { content: this.accumulatedContent.join('') };
    }
    /**
     * Check if the stream has finished.
     */
    get isComplete() {
        return this._isComplete;
    }
}
exports.DialecticStreamResponse = DialecticStreamResponse;
