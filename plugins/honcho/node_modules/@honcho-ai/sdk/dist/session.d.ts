import type { HonchoHTTPClient } from './http/client';
import { Message } from './message';
import { Page } from './pagination';
import { Peer } from './peer';
import { SessionContext, SessionSummaries } from './session_context';
import type { MessageResponse, QueueStatus, RepresentationOptions } from './types/api';
import { type Filters, type MessageAddition, type PeerAddition, type PeerRemoval, type QueueStatusOptions, type SessionConfig, type SessionPeerConfig } from './validation';
/**
 * Represents a session in the Honcho system.
 *
 * Sessions are conversation contexts that can involve multiple peers. They track
 * message history, manage peer participation with configurable observation settings,
 * and provide context retrieval for LLM interactions.
 *
 * @example
 * ```typescript
 * const session = await honcho.session('conversation-123')
 *
 * // Add peers to the session
 * await session.addPeers([user, assistant])
 *
 * // Add messages
 * await session.addMessages([
 *   user.message('Hello!'),
 *   assistant.message('Hi there!')
 * ])
 *
 * // Get context for LLM
 * const ctx = await session.context({ peerPerspective: assistant })
 * ```
 */
export declare class Session {
    /**
     * Unique identifier for this session.
     */
    readonly id: string;
    /**
     * Workspace ID for scoping operations.
     */
    readonly workspaceId: string;
    private _http;
    private _metadata?;
    private _configuration?;
    private _ensureWorkspace;
    /**
     * Cached metadata for this session. May be stale if the session
     * was not recently fetched from the API.
     *
     * Call getMetadata() to get the latest metadata from the server,
     * which will also update this cached value.
     */
    get metadata(): Record<string, unknown> | undefined;
    /**
     * Cached configuration for this session. May be stale if the session
     * was not recently fetched from the API.
     *
     * Call getConfiguration() to get the latest configuration from the server,
     * which will also update this cached value.
     */
    get configuration(): SessionConfig | undefined;
    /**
     * Initialize a new Session. **Do not call this directly, use the client.session() method instead.**
     *
     * @param id - Unique identifier for this session within the workspace
     * @param workspaceId - Workspace ID for scoping operations
     * @param http - Reference to the HTTP client instance
     * @param metadata - Optional metadata to initialize the cached value
     * @param configuration - Optional configuration to initialize the cached value
     */
    constructor(id: string, workspaceId: string, http: HonchoHTTPClient, metadata?: Record<string, unknown>, configuration?: SessionConfig, ensureWorkspace?: () => Promise<void>);
    private _getOrCreate;
    private _update;
    private _delete;
    private _clone;
    private _getContext;
    private _getSummaries;
    private _search;
    private _addPeers;
    private _setPeers;
    private _removePeers;
    private _listPeers;
    private _getPeerConfiguration;
    private _setPeerConfiguration;
    private _createMessages;
    private _listMessages;
    private _uploadFile;
    private _getQueueStatus;
    private _getRepresentation;
    private _updateMessage;
    /**
     * Add peers to this session.
     *
     * Makes an API call to add one or more peers to the session. Peers can be
     * specified as IDs, Peer objects, or with observation configuration.
     *
     * @param peers - Peers to add. Can be a single peer ID, Peer object, array of either,
     *                or an object mapping peer IDs to their observation config
     *
     * @example
     * ```typescript
     * // Add by ID
     * await session.addPeers('user-123')
     *
     * // Add multiple peers
     * await session.addPeers([user, assistant])
     *
     * // Add with observation config
     * await session.addPeers({
     *   'user-123': { observeMe: true, observeOthers: true },
     *   'assistant': { observeMe: false }
     * })
     * ```
     */
    addPeers(peers: PeerAddition): Promise<void>;
    /**
     * Set the peers for this session, replacing any existing peer list.
     *
     * Makes an API call to replace the session's peer list with the provided peers.
     * Any peers not included will be removed from the session.
     *
     * @param peers - Peers to set. Can be a single peer ID, Peer object, array of either,
     *                or an object mapping peer IDs to their observation config
     */
    setPeers(peers: PeerAddition): Promise<void>;
    /**
     * Remove peers from this session.
     *
     * Makes an API call to remove one or more peers from the session.
     *
     * @param peers - Peers to remove. Can be a single peer ID, Peer object, or array of either
     */
    removePeers(peers: PeerRemoval): Promise<void>;
    /**
     * Get all peers in this session.
     *
     * Makes an API call to retrieve all peers that are currently part of this session.
     *
     * @returns Promise resolving to an array of Peer objects in this session
     */
    peers(): Promise<Peer[]>;
    /**
     * Get the session-specific configuration for a peer.
     *
     * Makes an API call to retrieve the observation settings for a specific peer
     * within this session.
     *
     * @param peer - The peer to get configuration for (ID string or Peer object)
     * @returns Promise resolving to the peer's session configuration with observation settings
     */
    getPeerConfiguration(peer: string | Peer): Promise<SessionPeerConfig>;
    /**
     * Set the session-specific configuration for a peer.
     *
     * Makes an API call to update the observation settings for a specific peer
     * within this session.
     *
     * @param peer - The peer to configure (ID string or Peer object)
     * @param configuration - Configuration with observation settings
     * @param configuration.observeMe - Whether this peer's messages generate observations about them
     * @param configuration.observeOthers - Whether this peer observes other peers in the session
     */
    setPeerConfiguration(peer: string | Peer, configuration: SessionPeerConfig): Promise<void>;
    /**
     * Add messages to this session.
     *
     * Makes an API call to create one or more messages in the session. Messages
     * are processed asynchronously to update peer representations.
     *
     * @param messages - Messages to add. Can be a single MessageInput or array of them.
     *                   Use `peer.message()` to create MessageInput objects.
     * @returns Promise resolving to an array of created Message objects
     *
     * @example
     * ```typescript
     * // Add a single message
     * await session.addMessages(user.message('Hello!'))
     *
     * // Add multiple messages
     * await session.addMessages([
     *   user.message('Hello!'),
     *   assistant.message('Hi there!'),
     *   user.message('How are you?')
     * ])
     * ```
     */
    addMessages(messages: MessageAddition): Promise<Message[]>;
    /**
     * Get all messages in this session.
     *
     * Makes an API call to retrieve messages in the session, with optional filtering.
     *
     * @param filters - Optional filter criteria for messages. See
     *                  [search filters documentation](https://docs.honcho.dev/v3/documentation/core-concepts/features/using-filters).
     * @returns Promise resolving to a paginated Page of Message objects
     */
    messages(filters?: Filters): Promise<Page<Message, MessageResponse>>;
    /**
     * Get the current metadata for this session.
     *
     * Makes an API call to retrieve metadata associated with this session.
     * This method also updates the cached metadata property.
     *
     * @returns Promise resolving to a dictionary containing the session's metadata.
     *          Returns an empty dictionary if no metadata is set
     */
    getMetadata(): Promise<Record<string, unknown>>;
    /**
     * Set the metadata for this session.
     *
     * Makes an API call to update the metadata associated with this session.
     * This will overwrite any existing metadata with the provided values.
     * This method also updates the cached metadata property.
     *
     * @param metadata - A dictionary of metadata to associate with this session.
     *                   Keys must be strings, values can be any JSON-serializable type
     */
    setMetadata(metadata: Record<string, unknown>): Promise<void>;
    /**
     * Get the current configuration for this session.
     *
     * Makes an API call to retrieve configuration associated with this session.
     * This method also updates the cached configuration property.
     *
     * @returns Promise resolving to the session's configuration.
     *          Returns an empty object if no configuration is set
     */
    getConfiguration(): Promise<SessionConfig>;
    /**
     * Set the configuration for this session.
     *
     * Makes an API call to update the configuration associated with this session.
     * This will overwrite any existing configuration with the provided values.
     * This method also updates the cached configuration property.
     *
     * @param configuration - Configuration to associate with this session.
     *                        Includes reasoning, peerCard, summary, and dream settings.
     */
    setConfiguration(configuration: SessionConfig): Promise<void>;
    /**
     * Refresh cached metadata and configuration for this session.
     *
     * Makes a single API call to retrieve the latest metadata and configuration
     * associated with this session and updates the cached properties.
     */
    refresh(): Promise<void>;
    /**
     * Delete this session.
     *
     * Makes an API call to permanently delete the session and all its messages.
     * This action cannot be undone.
     */
    delete(): Promise<void>;
    /**
     * Clone this session.
     *
     * Makes an API call to create a copy of the session. If a message ID is provided,
     * the clone will only include messages up to and including that message.
     *
     * @param messageId - Optional message ID to clone up to. If not provided,
     *                    clones the entire session
     * @returns Promise resolving to the new cloned Session object
     */
    clone(messageId?: string): Promise<Session>;
    /**
     * Get context for this session, suitable for LLM prompts.
     *
     * Makes an API call to retrieve a curated context including messages, optional
     * summary, and peer representation. The context can be converted to OpenAI or
     * Anthropic message formats.
     *
     * @param options - Configuration options for context retrieval
     * @param options.summary - Whether to include a summary of earlier messages
     * @param options.tokens - Target token count for the context window
     * @param options.peerTarget - The peer to get representation for
     * @param options.lastUserMessage - Message text (string) or Message object whose content will be used for semantic search
     * @param options.peerPerspective - The peer whose perspective to use for representation
     * @param options.limitToSession - Whether to limit representation to this session only
     * @param options.representationOptions - Options for representation retrieval
     * @returns Promise resolving to a SessionContext with messages, summary, and representation
     *
     * @example
     * ```typescript
     * const ctx = await session.context({
     *   summary: true,
     *   peerPerspective: assistant,
     *   peerTarget: user
     * })
     *
     * // Convert to OpenAI format
     * const messages = ctx.toOpenAI(assistant)
     * ```
     */
    context(options?: {
        summary?: boolean;
        tokens?: number;
        peerTarget?: string | Peer;
        searchQuery?: string | Message;
        peerPerspective?: string | Peer;
        limitToSession?: boolean;
        representationOptions?: RepresentationOptions;
    }): Promise<SessionContext>;
    /**
     * Get the summaries for this session.
     *
     * Makes an API call to retrieve both short and long summaries for the session.
     * Summaries are generated automatically as messages accumulate.
     *
     * @returns Promise resolving to a SessionSummaries object with short and long summaries
     */
    summaries(): Promise<SessionSummaries>;
    /**
     * Search for messages in this session.
     *
     * Makes an API call to perform semantic search over messages in this session.
     *
     * @param query - The search query to use
     * @param options - Search options
     * @param options.filters - Optional filters to scope the search. See
     *                          [search filters documentation](https://docs.honcho.dev/v3/documentation/core-concepts/features/using-filters).
     * @param options.limit - Number of results to return (1-100, default: 10)
     * @returns Promise resolving to an array of Message objects matching the query
     */
    search(query: string, options?: {
        filters?: Filters;
        limit?: number;
    }): Promise<Message[]>;
    /**
     * Get the queue processing status for this session.
     *
     * Makes an API call to retrieve the current status of background processing
     * for messages in this session. The queue processes messages to update
     * peer representations.
     *
     * @param options - Configuration options for the status request
     * @param options.observer - Optional observer peer to scope the status to
     * @param options.sender - Optional sender peer to scope the status to
     * @returns Promise resolving to queue status information including work unit counts
     */
    queueStatus(options?: Omit<QueueStatusOptions, 'sessionId' | 'observerId' | 'senderId'> & {
        observer?: string | Peer;
        sender?: string | Peer;
    }): Promise<QueueStatus>;
    /**
     * Upload a file to this session as a message.
     *
     * Makes an API call to upload a file, which is processed and stored as one or
     * more messages in the session.
     *
     * @param file - The file to upload. Can be a File, Blob, or an object with
     *               filename, content (Buffer/Uint8Array), and content_type
     * @param peer - The peer who is uploading the file (ID string or Peer object)
     * @param options - Upload options
     * @param options.metadata - Optional metadata to associate with the message(s)
     * @param options.configuration - Optional configuration for processing
     * @param options.createdAt - Optional timestamp for the message (string or Date)
     * @returns Promise resolving to an array of Message objects created from the file
     *
     * @example
     * ```typescript
     * // Upload a File object (browser)
     * const messages = await session.uploadFile(fileInput.files[0], user)
     *
     * // Upload from Node.js buffer
     * const messages = await session.uploadFile({
     *   filename: 'document.pdf',
     *   content: fs.readFileSync('document.pdf'),
     *   content_type: 'application/pdf'
     * }, user)
     * ```
     */
    uploadFile(file: File | Blob | {
        filename: string;
        content: Buffer | Uint8Array;
        content_type: string;
    }, peer: string | Peer, options?: {
        metadata?: Record<string, unknown>;
        configuration?: Record<string, unknown>;
        createdAt?: string | Date;
    }): Promise<Message[]>;
    /**
     * Get a peer's representation scoped to this session.
     *
     * Makes an API call to retrieve the representation for a peer, limited to
     * conclusions derived from this session's messages.
     *
     * @param peer - The peer to get representation for (ID string or Peer object)
     * @param options - Representation options
     * @param options.target - Optional target peer for local representation
     * @param options.searchQuery - Optional semantic search query to filter conclusions
     * @param options.searchTopK - Number of semantically relevant conclusions to return
     * @param options.searchMaxDistance - Maximum semantic distance for search results (0.0-1.0)
     * @param options.includeMostFrequent - Whether to include the most frequent conclusions
     * @param options.maxConclusions - Maximum number of conclusions to include
     * @returns Promise resolving to a string representation containing conclusions
     */
    representation(peer: string | Peer, options?: {
        target?: string | Peer;
        searchQuery?: string;
        searchTopK?: number;
        searchMaxDistance?: number;
        includeMostFrequent?: boolean;
        maxConclusions?: number;
    }): Promise<string>;
    /**
     * Update the metadata of a message in this session.
     *
     * Makes an API call to update the metadata of a specific message.
     *
     * @param message - Either a Message object or a message ID string
     * @param metadata - The metadata to update for the message
     * @returns Promise resolving to the updated Message object
     */
    updateMessage(message: Message | string, metadata: Record<string, unknown>): Promise<Message>;
    /**
     * Return a string representation of the Session.
     *
     * @returns A string representation suitable for debugging
     */
    toString(): string;
}
