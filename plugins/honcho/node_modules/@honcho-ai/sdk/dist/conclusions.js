"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConclusionScope = exports.Conclusion = void 0;
const api_version_1 = require("./api-version");
const pagination_1 = require("./pagination");
/**
 * A conclusion from Honcho's reasoning system.
 *
 * Conclusions are facts derived from messages that help build a representation
 * of a peer.
 */
class Conclusion {
    constructor(id, content, observerId, observedId, sessionId, createdAt) {
        this.id = id;
        this.content = content;
        this.observerId = observerId;
        this.observedId = observedId;
        this.sessionId = sessionId;
        this.createdAt = createdAt;
    }
    static fromApiResponse(data) {
        return new Conclusion(data.id, data.content, data.observer_id, data.observed_id, data.session_id, data.created_at);
    }
    toString() {
        const truncatedContent = this.content.length > 50
            ? `${this.content.slice(0, 50)}...`
            : this.content;
        return `Conclusion(id='${this.id}', content='${truncatedContent}')`;
    }
}
exports.Conclusion = Conclusion;
/**
 * Scoped access to conclusions for a specific observer/observed relationship.
 */
class ConclusionScope {
    constructor(http, workspaceId, observer, observed, ensureWorkspace = async () => undefined) {
        this._http = http;
        this.workspaceId = workspaceId;
        this.observer = observer;
        this.observed = observed;
        this._ensureWorkspace = ensureWorkspace;
    }
    // ===========================================================================
    // Private API Methods
    // ===========================================================================
    async _list(params) {
        await this._ensureWorkspace();
        return this._http.post(`/${api_version_1.API_VERSION}/workspaces/${this.workspaceId}/conclusions/list`, {
            body: { filters: params.filters },
            query: { page: params.page, size: params.size },
        });
    }
    async _query(params) {
        await this._ensureWorkspace();
        return this._http.post(`/${api_version_1.API_VERSION}/workspaces/${this.workspaceId}/conclusions/query`, { body: params });
    }
    async _create(params) {
        await this._ensureWorkspace();
        return this._http.post(`/${api_version_1.API_VERSION}/workspaces/${this.workspaceId}/conclusions`, { body: params });
    }
    async _delete(conclusionId) {
        await this._ensureWorkspace();
        await this._http.delete(`/${api_version_1.API_VERSION}/workspaces/${this.workspaceId}/conclusions/${conclusionId}`);
    }
    async _getRepresentation(peerId, params) {
        await this._ensureWorkspace();
        return this._http.post(`/${api_version_1.API_VERSION}/workspaces/${this.workspaceId}/peers/${peerId}/representation`, { body: params });
    }
    // ===========================================================================
    // Public Methods
    // ===========================================================================
    /**
     * List conclusions in this scope.
     *
     * @param options - Optional configuration for the list request
     * @param options.page - Page number (1-indexed, default: 1)
     * @param options.size - Number of items per page (default: 50)
     * @param options.session - Optional session (ID string or Session object) to filter by
     * @returns Promise resolving to a Page of Conclusion objects
     */
    async list(options) {
        const resolvedSessionId = options?.session
            ? typeof options.session === 'string'
                ? options.session
                : options.session.id
            : undefined;
        const filters = {
            observer_id: this.observer,
            observed_id: this.observed,
        };
        if (resolvedSessionId) {
            filters.session_id = resolvedSessionId;
        }
        const response = await this._list({
            filters,
            page: options?.page ?? 1,
            size: options?.size ?? 50,
        });
        const fetchNextPage = async (page, size) => {
            return this._list({ filters, page, size });
        };
        return new pagination_1.Page(response, (item) => Conclusion.fromApiResponse(item), fetchNextPage);
    }
    /**
     * Semantic search for conclusions in this scope.
     */
    async query(query, topK = 10, distance) {
        const filters = {
            observer_id: this.observer,
            observed_id: this.observed,
        };
        const response = await this._query({
            query,
            top_k: topK,
            distance,
            filters,
        });
        return (response ?? []).map((item) => Conclusion.fromApiResponse(item));
    }
    /**
     * Delete a conclusion by ID.
     */
    async delete(conclusionId) {
        await this._delete(conclusionId);
    }
    /**
     * Create conclusions in this scope.
     */
    async create(conclusions) {
        const conclusionArray = Array.isArray(conclusions)
            ? conclusions
            : [conclusions];
        const requestConclusions = conclusionArray.map((obs) => ({
            content: obs.content,
            session_id: obs.sessionId === undefined
                ? null
                : typeof obs.sessionId === 'string'
                    ? obs.sessionId
                    : obs.sessionId.id,
            observer_id: this.observer,
            observed_id: this.observed,
        }));
        const response = await this._create({ conclusions: requestConclusions });
        return (response ?? []).map((item) => Conclusion.fromApiResponse(item));
    }
    /**
     * Get the computed representation for this scope.
     */
    async representation(options) {
        const response = await this._getRepresentation(this.observer, {
            target: this.observed,
            search_query: options?.searchQuery,
            search_top_k: options?.searchTopK,
            search_max_distance: options?.searchMaxDistance,
            include_most_frequent: options?.includeMostFrequent,
            max_conclusions: options?.maxConclusions,
        });
        return response.representation;
    }
    toString() {
        return `ConclusionScope(workspaceId='${this.workspaceId}', observer='${this.observer}', observed='${this.observed}')`;
    }
}
exports.ConclusionScope = ConclusionScope;
