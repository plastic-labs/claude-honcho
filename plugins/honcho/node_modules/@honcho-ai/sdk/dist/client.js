"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Honcho = void 0;
const api_version_1 = require("./api-version");
const client_1 = require("./http/client");
const message_1 = require("./message");
const pagination_1 = require("./pagination");
const peer_1 = require("./peer");
const session_1 = require("./session");
const utils_1 = require("./utils");
const validation_1 = require("./validation");
const DEFAULT_BASE_URL = 'https://api.honcho.dev';
/**
 * Main client for the Honcho TypeScript SDK.
 *
 * Provides access to peers, sessions, and workspace operations with configuration
 * from environment variables or explicit parameters. This is the primary entry
 * point for interacting with the Honcho conversational memory platform.
 *
 * @example
 * ```typescript
 * const honcho = new Honcho({
 *   apiKey: 'your-api-key',
 *   workspaceId: 'your-workspace-id'
 * })
 *
 * const peer = await honcho.peer('user123')
 * const session = await honcho.session('session456')
 * ```
 */
class Honcho {
    /**
     * Cached metadata for this workspace. May be stale if the workspace
     * was not recently fetched from the API.
     *
     * Call getMetadata() to get the latest metadata from the server,
     * which will also update this cached value.
     */
    get metadata() {
        return this._metadata;
    }
    /**
     * Cached configuration for this workspace. May be stale if the workspace
     * was not recently fetched from the API.
     *
     * Call getConfiguration() to get the latest configuration from the server,
     * which will also update this cached value.
     */
    get configuration() {
        return this._configuration;
    }
    /**
     * Access the underlying HTTP client for advanced usage.
     *
     * @returns The HTTP client instance
     */
    get http() {
        return this._http;
    }
    /**
     * Get the base URL for the API.
     */
    get baseURL() {
        return this._http.baseURL;
    }
    /**
     * Initialize the Honcho client.
     *
     * @param options - Configuration options for the client
     * @param options.apiKey - API key for authentication. If not provided, will attempt to
     *                         read from HONCHO_API_KEY environment variable
     * @param options.environment - Environment to use (local, production, or demo)
     * @param options.baseURL - Base URL for the Honcho API. If not provided, will attempt to
     *                          read from HONCHO_URL environment variable or default to the
     *                          production API URL
     * @param options.workspaceId - Workspace ID to use for operations. If not provided, will
     *                              attempt to read from HONCHO_WORKSPACE_ID environment variable
     *                              or default to "default"
     * @param options.timeout - Optional custom timeout for the HTTP client
     * @param options.maxRetries - Optional custom maximum number of retries for the HTTP client
     * @param options.defaultHeaders - Optional custom default headers for the HTTP client
     */
    constructor(options = {}) {
        const validatedOptions = validation_1.HonchoConfigSchema.parse(options);
        this.workspaceId =
            validatedOptions.workspaceId ||
                process.env.HONCHO_WORKSPACE_ID ||
                'default';
        // Resolve base URL
        let baseURL = validatedOptions.baseURL || process.env.HONCHO_URL;
        if (validatedOptions.environment === 'local') {
            baseURL = 'http://localhost:8000';
        }
        else if (!baseURL) {
            baseURL = DEFAULT_BASE_URL;
        }
        this._http = new client_1.HonchoHTTPClient({
            baseURL,
            apiKey: validatedOptions.apiKey || process.env.HONCHO_API_KEY,
            timeout: validatedOptions.timeout,
            maxRetries: validatedOptions.maxRetries,
            defaultHeaders: validatedOptions.defaultHeaders,
            defaultQuery: validatedOptions.defaultQuery,
        });
    }
    // ===========================================================================
    // Private API Methods
    // ===========================================================================
    async _getOrCreateWorkspace(id, params) {
        return this._http.post(`/${api_version_1.API_VERSION}/workspaces`, {
            body: {
                id,
                metadata: params?.metadata,
                configuration: (0, validation_1.workspaceConfigToApi)(params?.configuration),
            },
        });
    }
    async _ensureWorkspace() {
        /**
         * Ensure the workspace exists on the server.
         *
         * The Honcho API uses get-or-create semantics for workspaces via `POST /v3/workspaces`.
         * This SDK performs that call once per client instance (memoized) to guarantee that
         * all workspace-scoped operations run against an existing workspace.
         */
        if (!this._workspaceReady) {
            this._workspaceReady = this._getOrCreateWorkspace(this.workspaceId).then(() => undefined);
        }
        await this._workspaceReady;
    }
    async _updateWorkspace(workspaceId, params) {
        return this._http.put(`/${api_version_1.API_VERSION}/workspaces/${workspaceId}`, {
            body: {
                metadata: params.metadata,
                configuration: (0, validation_1.workspaceConfigToApi)(params.configuration),
            },
        });
    }
    async _deleteWorkspace(workspaceId) {
        await this._http.delete(`/${api_version_1.API_VERSION}/workspaces/${workspaceId}`);
    }
    async _listWorkspaces(params) {
        return this._http.post(`/${api_version_1.API_VERSION}/workspaces/list`, {
            body: {
                filters: params?.filters,
            },
            query: {
                page: params?.page,
                size: params?.size,
            },
        });
    }
    async _searchWorkspace(workspaceId, params) {
        return this._http.post(`/${api_version_1.API_VERSION}/workspaces/${workspaceId}/search`, { body: params });
    }
    async _getQueueStatus(workspaceId, params) {
        const query = {};
        if (params?.observer_id)
            query.observer_id = params.observer_id;
        if (params?.sender_id)
            query.sender_id = params.sender_id;
        if (params?.session_id)
            query.session_id = params.session_id;
        return this._http.get(`/${api_version_1.API_VERSION}/workspaces/${workspaceId}/queue/status`, { query });
    }
    async _listPeers(workspaceId, params) {
        return this._http.post(`/${api_version_1.API_VERSION}/workspaces/${workspaceId}/peers/list`, {
            body: { filters: params?.filters },
            query: { page: params?.page, size: params?.size },
        });
    }
    async _getOrCreatePeer(workspaceId, params) {
        return this._http.post(`/${api_version_1.API_VERSION}/workspaces/${workspaceId}/peers`, { body: params });
    }
    async _listSessions(workspaceId, params) {
        return this._http.post(`/${api_version_1.API_VERSION}/workspaces/${workspaceId}/sessions/list`, {
            body: { filters: params?.filters },
            query: { page: params?.page, size: params?.size },
        });
    }
    async _getOrCreateSession(workspaceId, params) {
        return this._http.post(`/${api_version_1.API_VERSION}/workspaces/${workspaceId}/sessions`, {
            body: {
                id: params.id,
                metadata: params.metadata,
                configuration: (0, validation_1.sessionConfigToApi)(params.configuration),
            },
        });
    }
    // ===========================================================================
    // Public Methods
    // ===========================================================================
    /**
     * Get or create a peer with the given ID.
     *
     * Creates a Peer object that can be used to interact with the specified peer.
     * If metadata or configuration is provided, makes an API call to get/create the peer
     * immediately with those values.
     *
     * Provided metadata and configuration will overwrite existing data for this peer
     * if it already exists.
     *
     * @param id - Unique identifier for the peer within the workspace. Should be a
     *             stable identifier that can be used consistently across sessions.
     * @param metadata - Optional metadata dictionary to associate with this peer.
     *                   If set, will get/create peer immediately with metadata.
     * @param configuration - Optional configuration to set for this peer.
     *                        If set, will get/create peer immediately with flags.
     * @returns Promise resolving to a Peer object that can be used to send messages,
     *          join sessions, and query the peer's knowledge representations
     * @throws Error if the peer ID is empty or invalid
     */
    async peer(id, options) {
        await this._ensureWorkspace();
        const validatedId = validation_1.PeerIdSchema.parse(id);
        const validatedMetadata = options?.metadata
            ? validation_1.PeerMetadataSchema.parse(options.metadata)
            : undefined;
        const validatedConfiguration = options?.configuration
            ? validation_1.PeerConfigSchema.parse(options.configuration)
            : undefined;
        if (validatedConfiguration || validatedMetadata) {
            const peerData = await this._getOrCreatePeer(this.workspaceId, {
                id: validatedId,
                configuration: (0, validation_1.peerConfigToApi)(validatedConfiguration),
                metadata: validatedMetadata,
            });
            return new peer_1.Peer(validatedId, this.workspaceId, this._http, peerData.metadata ?? undefined, (0, validation_1.peerConfigFromApi)(peerData.configuration) ?? undefined, () => this._ensureWorkspace());
        }
        return new peer_1.Peer(validatedId, this.workspaceId, this._http, undefined, undefined, () => this._ensureWorkspace());
    }
    /**
     * Get all peers in the current workspace.
     *
     * Makes an API call to retrieve all peers that have been created or used
     * within the current workspace. Returns a paginated result.
     *
     * @param filters - Optional filter criteria for peers. See [search filters documentation](https://docs.honcho.dev/v3/documentation/core-concepts/features/using-filters).
     * @returns Promise resolving to a Page of Peer objects representing all peers in the workspace
     */
    async peers(filters) {
        await this._ensureWorkspace();
        const validatedFilter = filters ? validation_1.FilterSchema.parse(filters) : undefined;
        const peersPage = await this._listPeers(this.workspaceId, {
            filters: validatedFilter,
        });
        const fetchNextPage = async (page, size) => {
            return this._listPeers(this.workspaceId, {
                filters: validatedFilter,
                page,
                size,
            });
        };
        return new pagination_1.Page(peersPage, (peer) => new peer_1.Peer(peer.id, this.workspaceId, this._http, peer.metadata ?? undefined, (0, validation_1.peerConfigFromApi)(peer.configuration) ?? undefined, () => this._ensureWorkspace()), fetchNextPage);
    }
    /**
     * Get or create a session with the given ID.
     *
     * Creates a Session object that can be used to manage conversations between
     * multiple peers. If metadata or configuration is provided, makes an API call to
     * get/create the session immediately with those values.
     *
     * Provided metadata and configuration will overwrite existing data for this session
     * if it already exists.
     *
     * @param id - Unique identifier for the session within the workspace. Should be a
     *             stable identifier that can be used consistently to reference the
     *             same conversation
     * @param metadata - Optional metadata dictionary to associate with this session.
     *                   If set, will get/create session immediately with metadata.
     * @param configuration - Optional configuration to set for this session.
     *                        If set, will get/create session immediately with flags.
     * @returns Promise resolving to a Session object that can be used to add peers,
     *          send messages, and manage conversation context
     * @throws Error if the session ID is empty or invalid
     */
    async session(id, options) {
        await this._ensureWorkspace();
        const validatedId = validation_1.SessionIdSchema.parse(id);
        const validatedMetadata = options?.metadata
            ? validation_1.SessionMetadataSchema.parse(options.metadata)
            : undefined;
        const validatedConfiguration = options?.configuration
            ? validation_1.SessionConfigSchema.parse(options.configuration)
            : undefined;
        if (validatedConfiguration || validatedMetadata) {
            const sessionData = await this._getOrCreateSession(this.workspaceId, {
                id: validatedId,
                configuration: validatedConfiguration,
                metadata: validatedMetadata,
            });
            return new session_1.Session(validatedId, this.workspaceId, this._http, sessionData.metadata ?? undefined, (0, validation_1.sessionConfigFromApi)(sessionData.configuration) ?? undefined, () => this._ensureWorkspace());
        }
        return new session_1.Session(validatedId, this.workspaceId, this._http, undefined, undefined, () => this._ensureWorkspace());
    }
    /**
     * Get all sessions in the current workspace.
     *
     * Makes an API call to retrieve all sessions that have been created within
     * the current workspace.
     *
     * @param filters - Optional filter criteria for sessions. See [search filters documentation](https://docs.honcho.dev/v3/documentation/core-concepts/features/using-filters).
     * @returns Promise resolving to a Page of Session objects representing all sessions
     *          in the workspace. Returns an empty page if no sessions exist
     */
    async sessions(filters) {
        await this._ensureWorkspace();
        const validatedFilter = filters ? validation_1.FilterSchema.parse(filters) : undefined;
        const sessionsPage = await this._listSessions(this.workspaceId, {
            filters: validatedFilter,
        });
        const fetchNextPage = async (page, size) => {
            return this._listSessions(this.workspaceId, {
                filters: validatedFilter,
                page,
                size,
            });
        };
        return new pagination_1.Page(sessionsPage, (session) => new session_1.Session(session.id, this.workspaceId, this._http, session.metadata ?? undefined, (0, validation_1.sessionConfigFromApi)(session.configuration) ?? undefined, () => this._ensureWorkspace()), fetchNextPage);
    }
    /**
     * Get metadata for the current workspace.
     *
     * Makes an API call to retrieve metadata associated with the current workspace.
     * Workspace metadata can include settings, configuration, or any other
     * key-value data associated with the workspace. This method also updates the
     * cached metadata property.
     *
     * @returns Promise resolving to a dictionary containing the workspace's metadata.
     *          Returns an empty dictionary if no metadata is set
     */
    async getMetadata() {
        await this._ensureWorkspace();
        const workspace = await this._getOrCreateWorkspace(this.workspaceId);
        this._metadata = workspace.metadata || {};
        return this._metadata;
    }
    /**
     * Set metadata for the current workspace.
     *
     * Makes an API call to update the metadata associated with the current workspace.
     * This will overwrite any existing metadata with the provided values.
     * This method also updates the cached metadata property.
     *
     * @param metadata - A dictionary of metadata to associate with the workspace.
     *                   Keys must be strings, values can be any JSON-serializable type
     */
    async setMetadata(metadata) {
        await this._ensureWorkspace();
        const validatedMetadata = validation_1.WorkspaceMetadataSchema.parse(metadata);
        await this._updateWorkspace(this.workspaceId, {
            metadata: validatedMetadata,
        });
        this._metadata = validatedMetadata;
    }
    /**
     * Get configuration for the current workspace.
     *
     * Makes an API call to retrieve configuration associated with the current workspace.
     * Configuration includes settings that control workspace behavior.
     * This method also updates the cached configuration property.
     *
     * @returns Promise resolving to the workspace's configuration.
     *          Returns an empty object if no configuration is set
     */
    async getConfiguration() {
        await this._ensureWorkspace();
        const workspace = await this._getOrCreateWorkspace(this.workspaceId);
        this._configuration = (0, validation_1.workspaceConfigFromApi)(workspace.configuration) || {};
        return this._configuration;
    }
    /**
     * Set configuration for the current workspace.
     *
     * Makes an API call to update the configuration associated with the current workspace.
     * This will overwrite any existing configuration with the provided values.
     * This method also updates the cached configuration property.
     *
     * @param configuration - Configuration to associate with the workspace.
     *                        Includes reasoning, peerCard, summary, and dream settings.
     */
    async setConfiguration(configuration) {
        await this._ensureWorkspace();
        const validatedConfig = validation_1.WorkspaceConfigSchema.parse(configuration);
        await this._updateWorkspace(this.workspaceId, {
            configuration: validatedConfig,
        });
        this._configuration = validatedConfig;
    }
    /**
     * Refresh cached metadata and configuration for the current workspace.
     *
     * Makes a single API call to retrieve the latest metadata and configuration
     * associated with the current workspace and updates the cached properties.
     */
    async refresh() {
        await this._ensureWorkspace();
        const workspace = await this._getOrCreateWorkspace(this.workspaceId);
        this._metadata = workspace.metadata || {};
        this._configuration = (0, validation_1.workspaceConfigFromApi)(workspace.configuration) || {};
    }
    /**
     * Get all workspace IDs from the Honcho instance.
     *
     * Makes an API call to retrieve all workspace IDs that the authenticated
     * user has access to.
     *
     * @param filters - Optional filter criteria for workspaces. See [search filters documentation](https://docs.honcho.dev/v3/documentation/core-concepts/features/using-filters).
     * @returns Promise resolving to a Page of workspace ID strings. Returns an empty
     *          page if no workspaces are accessible or none exist
     */
    async workspaces(filters) {
        const validatedFilter = filters ? validation_1.FilterSchema.parse(filters) : undefined;
        const workspacesPage = await this._listWorkspaces({
            filters: validatedFilter,
        });
        const fetchNextPage = async (page, size) => {
            return this._listWorkspaces({
                filters: validatedFilter,
                page,
                size,
            });
        };
        return new pagination_1.Page(workspacesPage, (workspace) => workspace.id, fetchNextPage);
    }
    /**
     * Delete a workspace.
     *
     * Makes an API call to delete the specified workspace.
     *
     * @param workspaceId - The ID of the workspace to delete
     * @returns Promise that resolves when the workspace is deleted
     */
    async deleteWorkspace(workspaceId) {
        await this._deleteWorkspace(workspaceId);
    }
    /**
     * Search for messages in the current workspace.
     *
     * Makes an API call to search for messages in the current workspace.
     *
     * @param query - The search query to use
     * @param filters - Optional filters to scope the search. See [search filters documentation](https://docs.honcho.dev/v3/documentation/core-concepts/features/using-filters).
     * @param limit - Number of results to return (1-100, default: 10).
     * @returns Promise resolving to an array of Message objects representing the search results.
     *          Returns an empty array if no messages are found.
     * @throws Error if the search query is empty or invalid
     */
    async search(query, options) {
        await this._ensureWorkspace();
        const validatedQuery = validation_1.SearchQuerySchema.parse(query);
        const validatedFilters = options?.filters
            ? validation_1.FilterSchema.parse(options.filters)
            : undefined;
        const validatedLimit = options?.limit
            ? validation_1.LimitSchema.parse(options.limit)
            : undefined;
        const response = await this._searchWorkspace(this.workspaceId, {
            query: validatedQuery,
            filters: validatedFilters,
            limit: validatedLimit,
        });
        return response.map(message_1.Message.fromApiResponse);
    }
    /**
     * Get the queue processing status, optionally scoped to an observer, sender, and/or session.
     *
     * Makes an API call to retrieve the current status of the queue processing queue.
     * The queue is responsible for processing messages and updating peer representations.
     *
     * @param options - Configuration options for the status request
     * @param options.observer - Optional observer (ID string or Peer object) to scope the status to
     * @param options.sender - Optional sender (ID string or Peer object) to scope the status to
     * @param options.session - Optional session (ID string or Session object) to scope the status to
     * @returns Promise resolving to the queue status information including work unit counts
     */
    async queueStatus(options) {
        await this._ensureWorkspace();
        const observerId = options?.observer
            ? (0, utils_1.resolveId)(options.observer)
            : undefined;
        const senderId = options?.sender ? (0, utils_1.resolveId)(options.sender) : undefined;
        const sessionId = options?.session ? (0, utils_1.resolveId)(options.session) : undefined;
        const queryParams = {};
        if (observerId)
            queryParams.observer_id = observerId;
        if (senderId)
            queryParams.sender_id = senderId;
        if (sessionId)
            queryParams.session_id = sessionId;
        const status = await this._getQueueStatus(this.workspaceId, queryParams);
        return (0, utils_1.transformQueueStatus)(status);
    }
    /**
     * Schedule a dream task for memory consolidation.
     *
     * Dreams are background processes that consolidate observations into higher-level
     * insights and update peer cards. This method schedules a dream task for immediate
     * processing.
     *
     * @param options - Configuration options for the dream
     * @param options.observer - The observer peer (ID string or Peer object) whose perspective
     *                          to use for the dream
     * @param options.session - The session (ID string or Session object) to scope the dream to
     * @param options.observed - Optional observed peer (ID string or Peer object). If not provided,
     *                          defaults to the observer (self-reflection)
     * @returns Promise that resolves when the dream is scheduled
     */
    async scheduleDream(options) {
        await this._ensureWorkspace();
        const observerId = (0, utils_1.resolveId)(options.observer);
        const sessionId = options.session ? (0, utils_1.resolveId)(options.session) : undefined;
        const observedId = options.observed
            ? (0, utils_1.resolveId)(options.observed)
            : observerId;
        await this._http.post(`/${api_version_1.API_VERSION}/workspaces/${this.workspaceId}/schedule_dream`, {
            body: {
                observer: observerId,
                observed: observedId,
                session_id: sessionId,
                dream_type: 'omni',
            },
        });
    }
    /**
     * Return a string representation of the Honcho client.
     *
     * @returns A string representation suitable for debugging
     */
    toString() {
        return `Honcho(workspaceId='${this.workspaceId}', baseURL='${this._http.baseURL}')`;
    }
}
exports.Honcho = Honcho;
