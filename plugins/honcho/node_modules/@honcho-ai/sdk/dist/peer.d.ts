import { ConclusionScope } from './conclusions';
import type { HonchoHTTPClient } from './http/client';
import { type DialecticStreamResponse } from './http/streaming';
import { Message, type MessageInput } from './message';
import { Page } from './pagination';
import { Session } from './session';
import type { PeerContextResponse, SessionResponse } from './types/api';
import { type Filters, type MessageConfiguration, type PeerConfig } from './validation';
/**
 * Represents context for a peer, including representation and peer card.
 */
export declare class PeerContext {
    /**
     * The peer ID this context belongs to.
     */
    readonly peerId: string;
    /**
     * The target peer ID if this is a local context.
     */
    readonly targetId: string;
    /**
     * The peer's representation, if available.
     */
    readonly representation: string | null;
    /**
     * The peer card, if available.
     */
    readonly peerCard: string[] | null;
    constructor(peerId: string, targetId: string, representation: string | null, peerCard: string[] | null);
    /**
     * Create a PeerContext from an API response.
     */
    static fromApiResponse(response: PeerContextResponse): PeerContext;
    toString(): string;
}
/**
 * Represents a peer in the Honcho system.
 *
 * Peers can send messages, participate in sessions, and maintain both global
 * and local representations for contextual interactions. A peer represents
 * an entity (user, assistant, etc.) that can communicate within the system.
 */
export declare class Peer {
    /**
     * Unique identifier for this peer.
     */
    readonly id: string;
    /**
     * Workspace ID for scoping operations.
     */
    readonly workspaceId: string;
    /**
     * Reference to the HTTP client instance.
     */
    private _http;
    private _ensureWorkspace;
    /**
     * Private cached metadata for this peer.
     */
    private _metadata?;
    /**
     * Private cached configuration for this peer.
     */
    private _configuration?;
    /**
     * Cached metadata for this peer. May be stale if the peer
     * was not recently fetched from the API.
     *
     * Call getMetadata() to get the latest metadata from the server,
     * which will also update this cached value.
     */
    get metadata(): Record<string, unknown> | undefined;
    /**
     * Cached configuration for this peer. May be stale if the peer
     * was not recently fetched from the API.
     *
     * Call getConfiguration() to get the latest configuration from the server,
     * which will also update this cached value.
     */
    get configuration(): PeerConfig | undefined;
    /**
     * Initialize a new Peer. **Do not call this directly, use the client.peer() method instead.**
     *
     * @param id - Unique identifier for this peer within the workspace
     * @param workspaceId - Workspace ID for scoping operations
     * @param http - Reference to the HTTP client instance
     * @param metadata - Optional metadata to initialize the cached value
     * @param configuration - Optional configuration to initialize the cached value (camelCase)
     */
    constructor(id: string, workspaceId: string, http: HonchoHTTPClient, metadata?: Record<string, unknown>, configuration?: PeerConfig, ensureWorkspace?: () => Promise<void>);
    private _getOrCreate;
    private _update;
    private _listSessions;
    private _chat;
    private _chatStream;
    private _search;
    private _getRepresentation;
    private _getContext;
    private _getCard;
    /**
     * Query the peer's representation with a natural language question.
     *
     * Makes an API call to the Honcho dialectic endpoint to query either the peer's
     * global representation (all content associated with this peer) or their local
     * representation of another peer (what this peer knows about the target peer).
     *
     * @param query - The natural language question to ask
     * @param options.target - Optional target peer for local representation query. If provided,
     *                         queries what this peer knows about the target peer rather than
     *                         querying the peer's global representation. Can be a peer ID string
     *                         or a Peer object.
     * @param options.session - Optional session to scope the query to. If provided, only
     *                          information from that session is considered. Can be a session
     *                          ID string or a Session object.
     * @param options.reasoningLevel - Optional reasoning level for the query: "minimal", "low", "medium",
     *                                 "high", or "max". Defaults to "low" if not provided.
     * @returns Promise resolving to the response string, or null if no relevant information
     *
     * @example
     * ```typescript
     * // Simple query
     * const response = await peer.chat('What do you know about this user?')
     *
     * // Query with options
     * const response = await peer.chat('What does this peer think about coding?', {
     *   target: otherPeer,
     *   reasoningLevel: 'high'
     * })
     * ```
     */
    chat(query: string, options?: {
        target?: string | Peer;
        session?: string | Session;
        reasoningLevel?: string;
    }): Promise<string | null>;
    /**
     * Query the peer's representation with a natural language question and stream the response.
     *
     * Makes an API call to the Honcho dialectic endpoint to query either the peer's
     * global representation (all content associated with this peer) or their local
     * representation of another peer (what this peer knows about the target peer).
     * The response is streamed back as it is generated.
     *
     * @param query - The natural language question to ask
     * @param options.target - Optional target peer for local representation query. If provided,
     *                         queries what this peer knows about the target peer rather than
     *                         querying the peer's global representation. Can be a peer ID string
     *                         or a Peer object.
     * @param options.session - Optional session to scope the query to. If provided, only
     *                          information from that session is considered. Can be a session
     *                          ID string or a Session object.
     * @param options.reasoningLevel - Optional reasoning level for the query: "minimal", "low", "medium",
     *                                 "high", or "max". Defaults to "low" if not provided.
     * @returns Promise resolving to a DialecticStreamResponse that can be iterated over
     *
     * @example
     * ```typescript
     * // Stream a response
     * const stream = await peer.chatStream('What do you know about this user?')
     * for await (const chunk of stream) {
     *   process.stdout.write(chunk)
     * }
     *
     * // Stream with options
     * const stream = await peer.chatStream('What does this peer think about coding?', {
     *   target: otherPeer,
     *   reasoningLevel: 'high'
     * })
     * ```
     */
    chatStream(query: string, options?: {
        target?: string | Peer;
        session?: string | Session;
        reasoningLevel?: string;
    }): Promise<DialecticStreamResponse>;
    /**
     * Get all sessions this peer is a member of.
     *
     * Makes an API call to retrieve all sessions where this peer is an active participant.
     * Sessions are created when peers are added to them or send messages to them.
     *
     * @param filters - Optional filter criteria for sessions. See [search filters documentation](https://docs.honcho.dev/v3/documentation/core-concepts/features/using-filters).
     * @returns Promise resolving to a paginated list of Session objects this peer belongs to.
     *          Returns an empty list if the peer is not a member of any sessions
     */
    sessions(filters?: Filters): Promise<Page<Session, SessionResponse>>;
    /**
     * Build a message object attributed to this peer (synchronous, no API call).
     *
     * This is a convenience method for creating message objects with this peer's ID
     * already set. The returned object can then be passed to `session.addMessages()`.
     *
     * **Note:** This method is synchronous and does NOT send the message to Honcho.
     * To actually create the message on the server, pass the returned object to
     * `session.addMessages()`.
     *
     * @param content - The text content for the message
     * @param options.metadata - Optional metadata to associate with the message
     * @param options.configuration - Optional message-level configuration (e.g., reasoning settings)
     * @param options.createdAt - Optional ISO 8601 timestamp for the message
     * @returns A message object ready to be passed to `session.addMessages()`
     *
     * @example
     * ```typescript
     * const msg = peer.message('Hello!')
     * await session.addMessages(msg)
     *
     * // Or batch multiple messages:
     * await session.addMessages([
     *   alice.message('Hi Bob'),
     *   bob.message('Hey Alice!')
     * ])
     * ```
     */
    message(content: string, options?: {
        metadata?: Record<string, unknown>;
        configuration?: MessageConfiguration;
        createdAt?: string | Date;
    }): MessageInput;
    /**
     * Get the current metadata for this peer.
     *
     * Makes an API call to retrieve metadata associated with this peer. Metadata
     * can include custom attributes, settings, or any other key-value data
     * associated with the peer. This method also updates the cached metadata property.
     *
     * @returns Promise resolving to a dictionary containing the peer's metadata.
     *          Returns an empty dictionary if no metadata is set
     */
    getMetadata(): Promise<Record<string, unknown>>;
    /**
     * Set the metadata for this peer.
     *
     * Makes an API call to update the metadata associated with this peer.
     * This will overwrite any existing metadata with the provided values.
     * This method also updates the cached metadata property.
     *
     * @param metadata - A dictionary of metadata to associate with this peer.
     *                   Keys must be strings, values can be any JSON-serializable type
     */
    setMetadata(metadata: Record<string, unknown>): Promise<void>;
    /**
     * Get the current workspace-level configuration for this peer.
     *
     * Makes an API call to retrieve configuration associated with this peer.
     * Configuration currently includes one optional flag, `observeMe`.
     * This method also updates the cached configuration property.
     *
     * @returns Promise resolving to the peer's configuration
     */
    getConfiguration(): Promise<PeerConfig>;
    /**
     * Set the configuration for this peer. Currently the only supported configuration
     * value is the `observeMe` flag, which controls whether derivation tasks
     * should be created for this peer's global representation. Default is true.
     *
     * Makes an API call to update the configuration associated with this peer.
     * This will overwrite any existing configuration with the provided values.
     * This method also updates the cached configuration property.
     *
     * @param configuration - Configuration to associate with this peer.
     *                        Supports `observeMe` (boolean) to control observation.
     */
    setConfiguration(configuration: PeerConfig): Promise<void>;
    /**
     * Refresh cached metadata and configuration for this peer.
     *
     * Makes a single API call to retrieve the latest metadata and configuration
     * associated with this peer and updates the cached properties.
     */
    refresh(): Promise<void>;
    /**
     * Search for messages in the workspace with this peer as author.
     *
     * Makes an API call to search endpoint.
     *
     * @param query The search query to use
     * @param filters - Optional filters to scope the search. See [search filters documentation](https://docs.honcho.dev/v3/documentation/core-concepts/features/using-filters).
     * @param limit - Optional limit on the number of results to return.
     * @returns Promise resolving to an array of Message objects representing the search results.
     *          Returns an empty array if no messages are found.
     */
    search(query: string, options?: {
        filters?: Filters;
        limit?: number;
    }): Promise<Message[]>;
    /**
     * Get the peer card for this peer.
     *
     * Makes an API call to retrieve the peer card, which contains a representation
     * of what this peer knows. If a target is provided, returns this peer's local
     * representation of the target peer.
     *
     * @param target - Optional target peer for local card. If provided, returns this
     *                 peer's card of the target peer. Can be a Peer object or peer ID string.
     * @returns Promise resolving to an array of strings containing the peer card items,
     *          or null if no peer card exists
     */
    card(target?: string | Peer): Promise<string[] | null>;
    /**
     * Get a subset of Honcho's Representation of a peer.
     *
     * Makes an API call to retrieve the representation for this peer.
     *
     * @param options.session - Optional session to scope the representation to.
     * @param options.target - Optional target peer to get the representation of. If provided,
     *                         returns the representation of the target from the perspective of this peer.
     * @param options.searchQuery - Optional semantic search query to filter relevant conclusions.
     * @param options.searchTopK - Number of semantically relevant conclusions to return.
     * @param options.searchMaxDistance - Maximum semantic distance for search results (0.0-1.0).
     * @param options.includeMostFrequent - Whether to include the most frequent conclusions.
     * @param options.maxConclusions - Maximum number of conclusions to include.
     * @returns Promise resolving to a string representation containing conclusions
     *
     * @example
     * ```typescript
     * // Get global representation
     * const globalRep = await peer.representation()
     *
     * // Get representation scoped to a session
     * const sessionRep = await peer.representation({ session: 'session-123' })
     *
     * // Get representation with semantic search
     * const searchedRep = await peer.representation({
     *   searchQuery: 'preferences',
     *   searchTopK: 10,
     *   maxConclusions: 50
     * })
     * ```
     */
    representation(options?: {
        session?: string | Session;
        target?: string | Peer;
        searchQuery?: string;
        searchTopK?: number;
        searchMaxDistance?: number;
        includeMostFrequent?: boolean;
        maxConclusions?: number;
    }): Promise<string>;
    /**
     * Get context for this peer, including representation and peer card.
     *
     * This is a convenience method that retrieves both the working representation
     * and peer card in a single API call.
     *
     * @param options.target - Optional target peer to get context for. If provided, returns
     *                         the context for the target from this peer's perspective.
     * @param options.searchQuery - Optional semantic search query to filter relevant conclusions.
     * @param options.searchTopK - Number of semantically relevant conclusions to return.
     * @param options.searchMaxDistance - Maximum semantic distance for search results (0.0-1.0).
     * @param options.includeMostFrequent - Whether to include the most frequent conclusions.
     * @param options.maxConclusions - Maximum number of conclusions to include.
     * @returns Promise resolving to a PeerContext object containing representation and peer card
     *
     * @example
     * ```typescript
     * // Get own context
     * const context = await peer.context()
     * console.log(context.representation?.toString())
     * console.log(context.peerCard)
     *
     * // Get context for another peer
     * const context = await peer.context({ target: 'other-peer-id' })
     *
     * // Get context with semantic search
     * const context = await peer.context({
     *   searchQuery: 'preferences',
     *   searchTopK: 10
     * })
     * ```
     */
    context(options?: {
        target?: string | Peer;
        searchQuery?: string;
        searchTopK?: number;
        searchMaxDistance?: number;
        includeMostFrequent?: boolean;
        maxConclusions?: number;
    }): Promise<PeerContext>;
    /**
     * Access this peer's self-conclusions (where observer == observed == self).
     *
     * This property provides a convenient way to access conclusions that this peer
     * has made about themselves. Use this for self-conclusion scenarios.
     *
     * @returns A ConclusionScope scoped to this peer's self-conclusions
     *
     * @example
     * ```typescript
     * // List self-conclusions
     * const obsList = await peer.conclusions.list()
     *
     * // Search self-conclusions
     * const results = await peer.conclusions.query('preferences')
     *
     * // Delete a self-conclusion
     * await peer.conclusions.delete('obs-123')
     * ```
     */
    get conclusions(): ConclusionScope;
    /**
     * Access conclusions this peer has made about another peer.
     *
     * This method provides scoped access to conclusions where this peer is the
     * observer and the target is the observed peer.
     *
     * @param target - The target peer (either a Peer object or peer ID string)
     * @returns A ConclusionScope scoped to this peer's conclusions of the target
     *
     * @example
     * ```typescript
     * // Get conclusions about another peer
     * const bobConclusions = peer.conclusionsOf('bob')
     *
     * // List conclusions
     * const obsList = await bobConclusions.list()
     *
     * // Search conclusions
     * const results = await bobConclusions.query('work history')
     *
     * // Get the representation from these conclusions
     * const rep = await bobConclusions.representation()
     * ```
     */
    conclusionsOf(target: string | Peer): ConclusionScope;
    /**
     * Return a string representation of the Peer.
     *
     * @returns A string representation suitable for debugging
     */
    toString(): string;
}
