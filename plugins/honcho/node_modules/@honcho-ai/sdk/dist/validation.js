"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConclusionQueryParamsSchema = exports.LimitSchema = exports.WorkspaceConfigSchema = exports.WorkspaceMetadataSchema = exports.MessageAdditionToApiSchema = exports.MessageAdditionSchema = exports.PeerRemovalSchema = exports.PeerAdditionToApiSchema = exports.PeerAdditionSchema = exports.CardTargetSchema = exports.PeerGetRepresentationParamsSchema = exports.GetRepresentationParamsSchema = exports.FileUploadSchema = exports.QueueStatusOptionsSchema = exports.ContextParamsSchema = exports.RepresentationOptionsSchema = exports.ChatQuerySchema = exports.FilterSchema = exports.SearchQuerySchema = exports.MessageInputSchema = exports.MessageConfigurationSchema = exports.MessageMetadataSchema = exports.MessageContentSchema = exports.SessionPeerConfigSchema = exports.SessionIdSchema = exports.SessionConfigSchema = exports.DreamConfigSchema = exports.SummaryConfigSchema = exports.PeerCardConfigSchema = exports.ReasoningConfigSchema = exports.SessionMetadataSchema = exports.PeerIdSchema = exports.PeerConfigSchema = exports.PeerMetadataSchema = exports.HonchoConfigSchema = exports.WorkspaceIdSchema = void 0;
exports.peerConfigToApi = peerConfigToApi;
exports.peerConfigFromApi = peerConfigFromApi;
exports.workspaceConfigToApi = workspaceConfigToApi;
exports.workspaceConfigFromApi = workspaceConfigFromApi;
exports.sessionConfigToApi = sessionConfigToApi;
exports.sessionConfigFromApi = sessionConfigFromApi;
exports.messageConfigToApi = messageConfigToApi;
exports.messageConfigFromApi = messageConfigFromApi;
const zod_1 = require("zod");
/**
 * Validation schemas for the Honcho TypeScript SDK.
 *
 * These schemas ensure type safety and runtime validation for all inputs
 * to the SDK, providing clear error messages when validation fails.
 */
/**
 * Schema for workspace ID validation.
 */
exports.WorkspaceIdSchema = zod_1.z
    .string()
    .min(1, 'Workspace ID must be a non-empty string')
    .regex(/^[a-zA-Z0-9_-]+$/, 'Workspace ID may only contain letters, numbers, underscores, and hyphens')
    .max(100, 'Workspace ID can be at most 100 characters');
/**
 * Schema for Honcho client configuration options.
 */
exports.HonchoConfigSchema = zod_1.z.object({
    apiKey: zod_1.z.string().optional(),
    environment: zod_1.z.enum(['local', 'production']).optional(),
    baseURL: zod_1.z.url('Base URL must be a valid URL').optional(),
    workspaceId: exports.WorkspaceIdSchema.optional(),
    timeout: zod_1.z.number().positive('Timeout must be a positive number').optional(),
    maxRetries: zod_1.z
        .number()
        .int()
        .min(0, 'Max retries must be a non-negative integer')
        .max(3, 'Max retries must be at most 3')
        .optional(),
    defaultHeaders: zod_1.z.record(zod_1.z.string(), zod_1.z.string()).optional(),
    defaultQuery: zod_1.z
        .record(zod_1.z.string(), zod_1.z.union([zod_1.z.string(), zod_1.z.number(), zod_1.z.boolean()]))
        .optional(),
});
/**
 * Schema for peer metadata.
 */
exports.PeerMetadataSchema = zod_1.z.record(zod_1.z.string(), zod_1.z.unknown());
/**
 * Schema for peer configuration.
 */
exports.PeerConfigSchema = zod_1.z.object({
    observeMe: zod_1.z.boolean().nullable().optional(),
});
/**
 * Schema for peer ID validation.
 */
exports.PeerIdSchema = zod_1.z
    .string()
    .min(1, 'Peer ID must be a non-empty string')
    .regex(/^[a-zA-Z0-9_-]+$/, 'Peer ID may only contain letters, numbers, underscores, and hyphens')
    .max(100, 'Peer ID can be at most 100 characters');
/**
 * Schema for session metadata.
 */
exports.SessionMetadataSchema = zod_1.z.record(zod_1.z.string(), zod_1.z.unknown());
// =============================================================================
// Configuration Schemas (typed)
// =============================================================================
/**
 * Schema for reasoning configuration.
 * Used in workspace, session, and message configuration.
 */
exports.ReasoningConfigSchema = zod_1.z.object({
    enabled: zod_1.z.boolean().nullable().optional(),
    customInstructions: zod_1.z.string().nullable().optional(),
});
/**
 * Schema for peer card configuration.
 * Used in workspace and session configuration.
 */
exports.PeerCardConfigSchema = zod_1.z.object({
    use: zod_1.z.boolean().nullable().optional(),
    create: zod_1.z.boolean().nullable().optional(),
});
/**
 * Schema for summary configuration.
 * Used in workspace and session configuration.
 */
exports.SummaryConfigSchema = zod_1.z.object({
    enabled: zod_1.z.boolean().nullable().optional(),
    messagesPerShortSummary: zod_1.z.number().int().min(10).nullable().optional(),
    messagesPerLongSummary: zod_1.z.number().int().min(20).nullable().optional(),
});
/**
 * Schema for dream configuration.
 * Used in workspace and session configuration.
 */
exports.DreamConfigSchema = zod_1.z.object({
    enabled: zod_1.z.boolean().nullable().optional(),
});
/**
 * Schema for session configuration.
 * Includes reasoning, peer card, summary, and dream settings.
 */
exports.SessionConfigSchema = zod_1.z.object({
    reasoning: exports.ReasoningConfigSchema.nullable().optional(),
    peerCard: exports.PeerCardConfigSchema.nullable().optional(),
    summary: exports.SummaryConfigSchema.nullable().optional(),
    dream: exports.DreamConfigSchema.nullable().optional(),
});
/**
 * Schema for session ID validation.
 */
exports.SessionIdSchema = zod_1.z
    .string()
    .min(1, 'Session ID must be a non-empty string')
    .regex(/^[a-zA-Z0-9_-]+$/, 'Session ID may only contain letters, numbers, underscores, and hyphens')
    .max(100, 'Session ID can be at most 100 characters');
/**
 * Schema for session peer configuration.
 */
exports.SessionPeerConfigSchema = zod_1.z.object({
    observeMe: zod_1.z.boolean().nullable().optional(),
    observeOthers: zod_1.z.boolean().nullable().optional(),
});
/**
 * Schema for message content.
 */
exports.MessageContentSchema = zod_1.z
    .string()
    .refine((content) => content === '' || content.trim().length > 0, 'Message content cannot be only whitespace');
/**
 * Schema for message metadata.
 */
exports.MessageMetadataSchema = zod_1.z
    .record(zod_1.z.string(), zod_1.z.unknown())
    .optional();
/**
 * Schema for message configuration.
 * Only includes reasoning settings.
 */
exports.MessageConfigurationSchema = zod_1.z
    .object({
    reasoning: exports.ReasoningConfigSchema.nullable().optional(),
})
    .nullable()
    .optional();
/**
 * Schema for message input.
 */
exports.MessageInputSchema = zod_1.z.object({
    peerId: exports.PeerIdSchema,
    content: exports.MessageContentSchema,
    metadata: exports.MessageMetadataSchema,
    configuration: exports.MessageConfigurationSchema,
    createdAt: zod_1.z.string().nullable().optional(),
});
/**
 * Schema for search query validation.
 */
exports.SearchQuerySchema = zod_1.z
    .string()
    .min(1, 'Search query must be a non-empty string')
    .refine((query) => query.trim().length > 0, 'Search query cannot be only whitespace');
/**
 * Schema for filter objects.
 */
exports.FilterSchema = zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()).optional();
/**
 * Schema for chat query parameters.
 */
exports.ChatQuerySchema = zod_1.z.object({
    query: exports.SearchQuerySchema,
    target: zod_1.z
        .union([exports.PeerIdSchema, zod_1.z.object({ id: exports.PeerIdSchema })])
        .optional()
        .transform((val) => val ? (typeof val === 'string' ? val : val.id) : undefined),
    session: zod_1.z
        .union([exports.SessionIdSchema, zod_1.z.object({ id: exports.SessionIdSchema })])
        .optional()
        .transform((val) => val ? (typeof val === 'string' ? val : val.id) : undefined),
    reasoningLevel: zod_1.z
        .enum(['minimal', 'low', 'medium', 'high', 'max'])
        .optional(),
});
/**
 * Schema for validating Message API responses (snake_case).
 */
const MessageResponseSchema = zod_1.z.object({
    id: zod_1.z.string(),
    content: zod_1.z.string(),
    created_at: zod_1.z.string(),
    peer_id: exports.PeerIdSchema,
    session_id: exports.SessionIdSchema,
    token_count: zod_1.z.number(),
    workspace_id: exports.WorkspaceIdSchema,
    metadata: zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()),
});
/**
 * Schema for representation options.
 */
exports.RepresentationOptionsSchema = zod_1.z.object({
    searchQuery: zod_1.z
        .string()
        .min(1, 'searchQuery must be a non-empty string')
        .refine((query) => query.trim().length > 0, 'searchQuery cannot be only whitespace')
        .optional(),
    searchTopK: zod_1.z
        .number()
        .int()
        .min(1, 'searchTopK must be at least 1')
        .max(100, 'searchTopK must be at most 100')
        .optional(),
    searchMaxDistance: zod_1.z
        .number()
        .min(0.0, 'searchMaxDistance must be at least 0.0')
        .max(1.0, 'searchMaxDistance must be at most 1.0')
        .optional(),
    includeMostFrequent: zod_1.z.boolean().optional(),
    maxConclusions: zod_1.z
        .number()
        .int()
        .min(1, 'maxConclusions must be at least 1')
        .max(100, 'maxConclusions must be at most 100')
        .optional(),
});
/**
 * Schema for context retrieval parameters.
 */
exports.ContextParamsSchema = zod_1.z
    .object({
    summary: zod_1.z.boolean().optional(),
    tokens: zod_1.z.int('Token limit must be an integer').optional(),
    searchQuery: zod_1.z
        .union([
        zod_1.z.string().min(1, 'Search query must be a non-empty string'),
        MessageResponseSchema,
    ])
        .optional(),
    peerTarget: exports.PeerIdSchema.optional(),
    peerPerspective: exports.PeerIdSchema.optional(),
    limitToSession: zod_1.z.boolean().optional(),
    representationOptions: exports.RepresentationOptionsSchema.optional(),
})
    .superRefine((data, ctx) => {
    if (data.searchQuery && !data.peerTarget) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'peerTarget is required when searchQuery is provided',
            path: ['searchQuery'],
        });
    }
    if (data.peerPerspective && !data.peerTarget) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'peerTarget is required when peerPerspective is provided',
            path: ['peerPerspective'],
        });
    }
});
/**
 * Schema for deriver status options.
 */
exports.QueueStatusOptionsSchema = zod_1.z.object({
    observer: zod_1.z.union([exports.PeerIdSchema, zod_1.z.object({ id: exports.PeerIdSchema })]).optional(),
    sender: zod_1.z.union([exports.PeerIdSchema, zod_1.z.object({ id: exports.PeerIdSchema })]).optional(),
    session: zod_1.z
        .union([exports.SessionIdSchema, zod_1.z.object({ id: exports.SessionIdSchema })])
        .optional(),
    timeout: zod_1.z.number().positive('Timeout must be a positive number').optional(),
});
/**
 * Schema for file upload parameters.
 * Supports File objects (browser), Buffer, Uint8Array, and custom uploadable objects.
 */
exports.FileUploadSchema = zod_1.z.object({
    file: zod_1.z.union([
        // Browser File object
        zod_1.z.instanceof(File),
        // Node.js Buffer
        zod_1.z.instanceof(Buffer),
        // Uint8Array
        zod_1.z.instanceof(Uint8Array),
        // Custom uploadable object with filename, content, and content_type
        zod_1.z.object({
            filename: zod_1.z.string().min(1, 'Filename must be a non-empty string'),
            content: zod_1.z.union([zod_1.z.instanceof(Buffer), zod_1.z.instanceof(Uint8Array)]),
            content_type: zod_1.z
                .string()
                .min(1, 'Content type must be a non-empty string'),
        }),
        // Fallback for any other uploadable type
        zod_1.z
            .any()
            .refine((val) => val !== null && val !== undefined, 'File must not be null or undefined'),
    ]),
    peer: zod_1.z.union([exports.PeerIdSchema, zod_1.z.object({ id: exports.PeerIdSchema })]),
    metadata: exports.MessageMetadataSchema,
    configuration: zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()).optional(),
    createdAt: zod_1.z.string().nullable().optional(),
});
/**
 * Schema for get representation parameters.
 */
exports.GetRepresentationParamsSchema = zod_1.z.object({
    peer: zod_1.z.union([exports.PeerIdSchema, zod_1.z.object({ id: exports.PeerIdSchema })]),
    target: zod_1.z.union([exports.PeerIdSchema, zod_1.z.object({ id: exports.PeerIdSchema })]).optional(),
    options: exports.RepresentationOptionsSchema.optional(),
});
/**
 * Schema for peer get representation parameters.
 */
exports.PeerGetRepresentationParamsSchema = zod_1.z.object({
    session: zod_1.z
        .union([exports.SessionIdSchema, zod_1.z.object({ id: exports.SessionIdSchema })])
        .optional(),
    target: zod_1.z.union([exports.PeerIdSchema, zod_1.z.object({ id: exports.PeerIdSchema })]).optional(),
    options: exports.RepresentationOptionsSchema.optional(),
});
/**
 * Schema for peer card target parameter.
 */
exports.CardTargetSchema = zod_1.z
    .union([exports.PeerIdSchema, zod_1.z.object({ id: exports.PeerIdSchema })])
    .optional()
    .transform((val) => val ? (typeof val === 'string' ? val : val.id) : undefined);
/**
 * Schema for peer addition to session.
 */
exports.PeerAdditionSchema = zod_1.z.union([
    exports.PeerIdSchema,
    zod_1.z.object({ id: exports.PeerIdSchema }),
    zod_1.z.array(zod_1.z.union([
        exports.PeerIdSchema,
        zod_1.z.object({ id: exports.PeerIdSchema }),
        zod_1.z.tuple([
            zod_1.z.union([exports.PeerIdSchema, zod_1.z.object({ id: exports.PeerIdSchema })]),
            exports.SessionPeerConfigSchema,
        ]),
    ])),
    zod_1.z.tuple([
        zod_1.z.union([exports.PeerIdSchema, zod_1.z.object({ id: exports.PeerIdSchema })]),
        exports.SessionPeerConfigSchema,
    ]),
]);
/**
 * Transform peer config to API format.
 */
function peerConfigToApi(config) {
    if (!config)
        return undefined;
    return {
        observe_me: config.observeMe,
    };
}
/**
 * Transform peer config from snake_case (API) to camelCase (SDK).
 */
function peerConfigFromApi(config) {
    if (!config)
        return undefined;
    const apiConfig = config;
    return {
        observeMe: apiConfig.observe_me,
    };
}
// =============================================================================
// Configuration Conversion Functions
// =============================================================================
/**
 * Transform reasoning config to API format.
 */
function reasoningConfigToApi(config) {
    if (config === null)
        return null;
    if (config === undefined)
        return undefined;
    return {
        enabled: config.enabled,
        custom_instructions: config.customInstructions,
    };
}
/**
 * Transform reasoning config from API format.
 */
function reasoningConfigFromApi(config) {
    if (config === null)
        return null;
    if (config === undefined)
        return undefined;
    return {
        enabled: config.enabled,
        customInstructions: config.custom_instructions,
    };
}
/**
 * Transform peer card config to API format.
 */
function peerCardConfigToApi(config) {
    if (config === null)
        return null;
    if (config === undefined)
        return undefined;
    return {
        use: config.use,
        create: config.create,
    };
}
/**
 * Transform peer card config from API format.
 */
function peerCardConfigFromApi(config) {
    if (config === null)
        return null;
    if (config === undefined)
        return undefined;
    return {
        use: config.use,
        create: config.create,
    };
}
/**
 * Transform summary config to API format.
 */
function summaryConfigToApi(config) {
    if (config === null)
        return null;
    if (config === undefined)
        return undefined;
    return {
        enabled: config.enabled,
        messages_per_short_summary: config.messagesPerShortSummary,
        messages_per_long_summary: config.messagesPerLongSummary,
    };
}
/**
 * Transform summary config from API format.
 */
function summaryConfigFromApi(config) {
    if (config === null)
        return null;
    if (config === undefined)
        return undefined;
    return {
        enabled: config.enabled,
        messagesPerShortSummary: config.messages_per_short_summary,
        messagesPerLongSummary: config.messages_per_long_summary,
    };
}
/**
 * Transform dream config to API format.
 */
function dreamConfigToApi(config) {
    if (config === null)
        return null;
    if (config === undefined)
        return undefined;
    return {
        enabled: config.enabled,
    };
}
/**
 * Transform dream config from API format.
 */
function dreamConfigFromApi(config) {
    if (config === null)
        return null;
    if (config === undefined)
        return undefined;
    return {
        enabled: config.enabled,
    };
}
/**
 * Transform workspace config to API format (camelCase to snake_case).
 */
function workspaceConfigToApi(config) {
    if (!config)
        return undefined;
    return {
        reasoning: reasoningConfigToApi(config.reasoning),
        peer_card: peerCardConfigToApi(config.peerCard),
        summary: summaryConfigToApi(config.summary),
        dream: dreamConfigToApi(config.dream),
    };
}
/**
 * Transform workspace config from API format (snake_case to camelCase).
 */
function workspaceConfigFromApi(config) {
    if (!config)
        return undefined;
    const apiConfig = config;
    return {
        reasoning: reasoningConfigFromApi(apiConfig.reasoning),
        peerCard: peerCardConfigFromApi(apiConfig.peer_card),
        summary: summaryConfigFromApi(apiConfig.summary),
        dream: dreamConfigFromApi(apiConfig.dream),
    };
}
/**
 * Transform session config to API format (camelCase to snake_case).
 */
function sessionConfigToApi(config) {
    if (!config)
        return undefined;
    return {
        reasoning: reasoningConfigToApi(config.reasoning),
        peer_card: peerCardConfigToApi(config.peerCard),
        summary: summaryConfigToApi(config.summary),
        dream: dreamConfigToApi(config.dream),
    };
}
/**
 * Transform session config from API format (snake_case to camelCase).
 */
function sessionConfigFromApi(config) {
    if (!config)
        return undefined;
    const apiConfig = config;
    return {
        reasoning: reasoningConfigFromApi(apiConfig.reasoning),
        peerCard: peerCardConfigFromApi(apiConfig.peer_card),
        summary: summaryConfigFromApi(apiConfig.summary),
        dream: dreamConfigFromApi(apiConfig.dream),
    };
}
/**
 * Transform message config to API format (camelCase to snake_case).
 */
function messageConfigToApi(config) {
    if (!config)
        return undefined;
    return {
        reasoning: reasoningConfigToApi(config.reasoning),
    };
}
/**
 * Transform message config from API format (snake_case to camelCase).
 */
function messageConfigFromApi(config) {
    if (!config)
        return undefined;
    const apiConfig = config;
    return {
        reasoning: reasoningConfigFromApi(apiConfig.reasoning),
    };
}
/**
 * Check if a value is a config object (has observeMe or observeOthers).
 */
function isSessionPeerConfig(val) {
    return (typeof val === 'object' &&
        val !== null &&
        !('id' in val) &&
        ('observeMe' in val || 'observeOthers' in val));
}
/**
 * Check if input is a tuple [peer, config].
 */
function isTuple(input) {
    return (Array.isArray(input) && input.length === 2 && isSessionPeerConfig(input[1]));
}
/**
 * Schema that validates and transforms peer addition input to API format.
 * Handles all input variations and outputs a dictionary ready for the API.
 */
exports.PeerAdditionToApiSchema = exports.PeerAdditionSchema.transform((input) => {
    const result = {};
    // Helper to process a single peer entry
    const processEntry = (entry) => {
        if (typeof entry === 'string') {
            result[entry] = {};
        }
        else if (isTuple(entry)) {
            const [peer, config] = entry;
            const id = typeof peer === 'string' ? peer : peer.id;
            result[id] = {
                observe_me: config.observeMe,
                observe_others: config.observeOthers,
            };
        }
        else if (typeof entry === 'object' && entry !== null && 'id' in entry) {
            result[entry.id] = {};
        }
    };
    // Handle single tuple specially (it's an array but represents one entry)
    if (isTuple(input)) {
        processEntry(input);
    }
    else if (Array.isArray(input)) {
        // Array of entries
        for (const item of input) {
            processEntry(item);
        }
    }
    else {
        // Single string or object
        processEntry(input);
    }
    return result;
});
/**
 * Schema for peer removal from session.
 */
exports.PeerRemovalSchema = zod_1.z.union([
    exports.PeerIdSchema,
    zod_1.z.object({ id: exports.PeerIdSchema }),
    zod_1.z.array(zod_1.z.union([exports.PeerIdSchema, zod_1.z.object({ id: exports.PeerIdSchema })])),
]);
/**
 * Schema for message addition to session.
 */
exports.MessageAdditionSchema = zod_1.z.union([
    exports.MessageInputSchema,
    zod_1.z.array(exports.MessageInputSchema),
]);
/**
 * Schema that validates and transforms message addition to API format.
 */
exports.MessageAdditionToApiSchema = exports.MessageAdditionSchema.transform((input) => {
    const messages = Array.isArray(input) ? input : [input];
    return messages.map((msg) => ({
        peer_id: msg.peerId,
        content: msg.content,
        metadata: msg.metadata,
        configuration: messageConfigToApi(msg.configuration ?? undefined),
        created_at: msg.createdAt,
    }));
});
/**
 * Schema for workspace metadata.
 */
exports.WorkspaceMetadataSchema = zod_1.z.record(zod_1.z.string(), zod_1.z.unknown());
/**
 * Schema for workspace configuration.
 * Includes reasoning, peer card, summary, and dream settings.
 */
exports.WorkspaceConfigSchema = zod_1.z.object({
    reasoning: exports.ReasoningConfigSchema.nullable().optional(),
    peerCard: exports.PeerCardConfigSchema.nullable().optional(),
    summary: exports.SummaryConfigSchema.nullable().optional(),
    dream: exports.DreamConfigSchema.nullable().optional(),
});
/**
 * Schema for limit.
 */
exports.LimitSchema = zod_1.z
    .number()
    .int()
    .min(1, 'Limit must be a positive integer')
    .max(100, 'Limit must be less than or equal to 100');
/**
 * Schema for conclusion query parameters.
 */
exports.ConclusionQueryParamsSchema = zod_1.z.object({
    query: exports.SearchQuerySchema,
    top_k: zod_1.z
        .number()
        .int()
        .min(1, 'top_k must be at least 1')
        .max(100, 'top_k must be at most 100')
        .optional(),
    distance: zod_1.z
        .number()
        .min(0.0, 'distance must be at least 0.0')
        .max(1.0, 'distance must be at most 1.0')
        .optional(),
    filters: exports.FilterSchema,
});
