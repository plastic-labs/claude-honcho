"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HonchoHTTPClient = void 0;
const errors_1 = require("./errors");
const DEFAULT_TIMEOUT = 60000; // 60 seconds
const DEFAULT_MAX_RETRIES = 2;
const RETRY_STATUS_CODES = [429, 500, 502, 503, 504];
const INITIAL_RETRY_DELAY = 500; // 500ms
/**
 * Minimal HTTP client for the Honcho API with retry logic and timeout support.
 */
class HonchoHTTPClient {
    constructor(config) {
        // Remove trailing slash from baseURL
        this.baseURL = config.baseURL.replace(/\/$/, '');
        this.apiKey = config.apiKey;
        this.timeout = config.timeout ?? DEFAULT_TIMEOUT;
        this.maxRetries = config.maxRetries ?? DEFAULT_MAX_RETRIES;
        this.defaultHeaders = {
            'Content-Type': 'application/json',
            ...config.defaultHeaders,
        };
        this.defaultQuery = config.defaultQuery;
    }
    /**
     * Make an HTTP request with automatic retries and timeout handling.
     */
    async request(method, path, options = {}) {
        const url = this.buildURL(path, options.query);
        const headers = this.buildHeaders(options.headers);
        const timeout = options.timeout ?? this.timeout;
        let lastError;
        let attempt = 0;
        while (attempt <= this.maxRetries) {
            try {
                const response = await this.fetchWithTimeout(url, {
                    method,
                    headers,
                    body: options.body ? JSON.stringify(options.body) : undefined,
                    signal: options.signal,
                }, timeout);
                if (response.ok) {
                    const text = await response.text();
                    if (!text) {
                        // Empty responses (204 No Content, etc.) - valid for DELETE and some PUT/POST
                        // Callers using void as T will get undefined which is correct
                        // Callers expecting data from an endpoint that returns empty will get undefined
                        return undefined;
                    }
                    return JSON.parse(text);
                }
                // Handle error responses
                const errorBody = await this.parseErrorBody(response);
                const retryAfter = this.parseRetryAfter(response);
                const error = (0, errors_1.createErrorFromResponse)(response.status, errorBody.message || `HTTP ${response.status}`, errorBody, retryAfter);
                // Only retry on specific status codes
                if (RETRY_STATUS_CODES.includes(response.status) &&
                    attempt < this.maxRetries) {
                    lastError = error;
                    await this.sleep(this.getRetryDelay(attempt, retryAfter));
                    attempt++;
                    continue;
                }
                throw error;
            }
            catch (error) {
                if (error instanceof errors_1.TimeoutError || error instanceof errors_1.ConnectionError) {
                    // Retry on network errors
                    if (attempt < this.maxRetries) {
                        lastError = error;
                        await this.sleep(this.getRetryDelay(attempt));
                        attempt++;
                        continue;
                    }
                }
                // Don't retry on other errors, just throw
                if (error instanceof errors_1.RateLimitError ||
                    error instanceof errors_1.ServerError ||
                    error instanceof errors_1.TimeoutError ||
                    error instanceof errors_1.ConnectionError) {
                    throw error;
                }
                // Handle fetch errors (network issues)
                if (error instanceof TypeError && error.message.includes('fetch')) {
                    const connError = new errors_1.ConnectionError(error.message);
                    if (attempt < this.maxRetries) {
                        lastError = connError;
                        await this.sleep(this.getRetryDelay(attempt));
                        attempt++;
                        continue;
                    }
                    throw connError;
                }
                throw error;
            }
        }
        // If we exhausted retries, throw the last error
        throw lastError || new Error('Request failed after retries');
    }
    /**
     * Make a GET request.
     */
    async get(path, options) {
        return this.request('GET', path, options);
    }
    /**
     * Make a POST request.
     */
    async post(path, options) {
        return this.request('POST', path, options);
    }
    /**
     * Make a PUT request.
     */
    async put(path, options) {
        return this.request('PUT', path, options);
    }
    /**
     * Make a PATCH request.
     */
    async patch(path, options) {
        return this.request('PATCH', path, options);
    }
    async delete(path, options) {
        return this.request('DELETE', path, options);
    }
    /**
     * Make a streaming request that returns a Response object for SSE parsing.
     */
    async stream(method, path, options = {}) {
        const url = this.buildURL(path, options.query);
        const headers = {
            ...this.buildHeaders(options.headers),
            Accept: 'text/event-stream',
        };
        const timeout = options.timeout ?? this.timeout;
        const response = await this.fetchWithTimeout(url, {
            method,
            headers,
            body: options.body ? JSON.stringify(options.body) : undefined,
            signal: options.signal,
        }, timeout);
        if (!response.ok) {
            const errorBody = await this.parseErrorBody(response);
            throw (0, errors_1.createErrorFromResponse)(response.status, errorBody.message || `HTTP ${response.status}`, errorBody);
        }
        return response;
    }
    /**
     * Make a multipart form data request (for file uploads).
     */
    async upload(path, formData, options = {}) {
        const url = this.buildURL(path, options.query);
        // Don't set Content-Type for FormData - browser will set it with boundary
        const headers = {};
        if (this.apiKey) {
            headers.Authorization = `Bearer ${this.apiKey}`;
        }
        if (options.headers) {
            Object.assign(headers, options.headers);
        }
        const timeout = options.timeout ?? this.timeout;
        const response = await this.fetchWithTimeout(url, {
            method: 'POST',
            headers,
            body: formData,
            signal: options.signal,
        }, timeout);
        if (!response.ok) {
            const errorBody = await this.parseErrorBody(response);
            throw (0, errors_1.createErrorFromResponse)(response.status, errorBody.message || `HTTP ${response.status}`, errorBody);
        }
        const text = await response.text();
        if (!text) {
            // Empty upload responses are unusual but valid for some endpoints
            return undefined;
        }
        return JSON.parse(text);
    }
    buildURL(path, query) {
        const url = new URL(path, this.baseURL);
        const mergedQuery = {
            ...(this.defaultQuery ?? {}),
            ...(query ?? {}),
        };
        for (const [key, value] of Object.entries(mergedQuery)) {
            if (value !== undefined) {
                url.searchParams.set(key, String(value));
            }
        }
        return url.toString();
    }
    buildHeaders(extra) {
        const headers = { ...this.defaultHeaders };
        if (this.apiKey) {
            headers.Authorization = `Bearer ${this.apiKey}`;
        }
        if (extra) {
            Object.assign(headers, extra);
        }
        return headers;
    }
    async fetchWithTimeout(url, init, timeout) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        // Combine with any existing signal
        if (init.signal) {
            init.signal.addEventListener('abort', () => controller.abort());
        }
        try {
            const response = await fetch(url, {
                ...init,
                signal: controller.signal,
            });
            return response;
        }
        catch (error) {
            if (error instanceof DOMException && error.name === 'AbortError') {
                throw new errors_1.TimeoutError(`Request timed out after ${timeout}ms`);
            }
            throw error;
        }
        finally {
            clearTimeout(timeoutId);
        }
    }
    async parseErrorBody(response) {
        try {
            const body = await response.json();
            return {
                message: body.detail || body.message || body.error,
                ...body,
            };
        }
        catch {
            return { message: `HTTP ${response.status}` };
        }
    }
    parseRetryAfter(response) {
        const header = response.headers.get('Retry-After');
        if (!header)
            return undefined;
        const seconds = Number.parseInt(header, 10);
        if (!Number.isNaN(seconds)) {
            return seconds * 1000; // Convert to milliseconds
        }
        // Try parsing as date
        const date = Date.parse(header);
        if (!Number.isNaN(date)) {
            return Math.max(0, date - Date.now());
        }
        return undefined;
    }
    getRetryDelay(attempt, retryAfter) {
        if (retryAfter) {
            return retryAfter;
        }
        // Exponential backoff: 500ms, 1000ms, 2000ms, etc.
        return INITIAL_RETRY_DELAY * 2 ** attempt;
    }
    sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
}
exports.HonchoHTTPClient = HonchoHTTPClient;
